## jvm内存管理
### 运行时内存划分
* 程序计数器
> 当前线程执行的字节码的行号指示器，通过改变计数器来选取下一条需执行的字节码指令；
是线程私有的；
* java虚拟机栈
> 线程私有；生命周期与线程相同，是java方法执行的内存模型，每个方法对应一个栈帧；
存储局部变量表、操作数栈、动态链接、方法出口等信息；
* 本地方法栈
> native方法执行的内存模型；
* java堆
> 是虚拟机管理的最大的内存，是线程共享的；主要存放对象、数组，是垃圾收集器
管理的主要区域；可细分为新生代、老年代；亦可再细分为Eden空间 From Survivor空间、
To Survivor空间等；
* 方法区
> 线程共享的；存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等；
(永久带在1.7之后已经移除)
* 运行时常量池
 > 是方法区的一部分
* 直接内存
> 不是虚拟机运行时数据，在NIO中有用到；受本机总内存限制；
### hotspot虚拟机对象探秘
* 对象的创建(普通对象，非数组和Class对象)
> 首先去常量池中定位类的符号引用，并检查类是否已被加载、解析、初始化过，新建对象
所需的内存大小在加载后可以确定；随后会在堆中划分所需大小的内存(不同虚拟机有不
同的实现)；接着把分配的内存初始化为零值，最后执行init;
* 对象的内存布局
> 可分为对象头、实例数据、对齐填充；对象头包含存储对象自身的运行时数据(哈希码、
GC分代年龄、锁状态标志、线程池有的锁、偏向线程ID、偏向时间戳等)和类型指针；
实例数据包括代码中定义的各种类型的字段,包含父类中的字段；对齐填充是为了保障对象
起始地址必须是8字节的整数倍而做的填充；
* 对象的访问定位
> 通过栈上的reference来操作堆上具体对象，有两种定位方式：句柄、直接指针；
句柄形式是在堆内存中划分一块句柄池，reference存句柄的地址，句柄中包含对象实例数据
和类型数据各自的具体地址；直接指针是reference存对象的具体地址，对象头中的类型指针
指向类型数据的地址；后者快，也是HotSpot采用的方式；
### 实战OutOfMemoryError异常
> 除了程序计数器之外，其他的内存区域都有发生OOM异常的可能；
###### 常用jvm参数
````
-Xms20M                             初始堆大小	
-Xmx20M	                            最大堆大小
-Xss128K                              线程栈帧的大小
-XX:+HeapDumpOnOutOfMemoryError     dump堆栈信息
-XX:PermSize=10M                    初始永久带大小(1.7后失效)
-XX:MaxPermSize=10M                 最大永久带大小(1.7后失效)

-XX:+PrintGCDetails                 打印GC详细信息
````


## 垃圾收集器与内存分配策略
* 为什么要了解GC和内存分配
> 当需要排查各种OOM、GC成为系统达到更高并发量的瓶颈时，需要对这些技术做必要的监控
和调节
### 对象已死吗
##### 1. 引用计数算法
> 描述：每当一个地方引用它，计数器+1，引用失效时，计数器-1，任何时刻计数器==0时，
对象不能再使用了；缺点：对象之间互相循环引用
##### 2. 可达性算法
> 描述：从一系列GC Roots的对象作为起点，通过引用链(Reference Chain)判定对象
是否可达；
###### GCRoots对象
    1. 虚拟机栈(本地变量表)中引用的对象
    2. 方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象
    4. 本地方法栈中native引用的对象
##### 3. 引用
> 引用可分为强引用(Strong Reference)、软引用(Soft Reference)、
弱引用(Weak Reference)、虚引用(Phantom Reference)强引用为new的对象，
 其他引用在jdk中都有对应的类
##### 4. 生存还是死亡
> finalize()是GC在收集垃圾之前会执行的，只有被覆盖了才会执行(不建议自己覆盖)
#### 5. 回收方法区
### 垃圾收集算法
#####1. 标记-清除算法
> 描述：在判定对象是否已经死亡(是否可达)时候，将死亡的对象作标记，是最基础的算法;
缺点：①标记和清除两个过程效率不高；②会产生大量不连续的内存碎片，导致无法分配足够
的连续内存而提前触发另一次GC
#####2. 复制算法
> 描述： 将内存划分为相同大小的两块，每次使用一块，当这块内存用完了，就将存活
的对象复制到另一块，再把这块内存清空；缺点：内存缩小到原来的一半；(新生代采用)
#####3. 标记-整理算法：
> 描述：将对象标记后，将存活的对象向一端移动，然后直接清除端边界以外的内存
(老年代采用)
#####4.分代收集算法
> 描述：根据对象存活周几不同将内存划分为几块，一般分为新生代、老年代，再根据不同周期
的特点采用最适当的手机算法；(新生代采用复制算法)(老年代采用标记-清理或标记-整理)
### HotSpot的算法实现
##### 1. 枚举根节点
##### 2. 安全点
##### 3. 安全区域
### 垃圾收集器
![垃圾收集器组合图](https://cdn.app.compendium.com/uploads/user/e7c690e8-6ff9-102a-ac6d-e4aebca50425/f4a5b21d-66fa-4885-92bf-c4e81c06d916/Image/b125abbe194f5608840119eccc9d90e2/collectors.jpg)
##### 1. Serial收集器
> 单线程收集器，用于新生代垃圾收集，采用复制算法；适合在桌面应用场景中使用
(运行在Client模式下的虚拟机)
##### 2. ParNew收集器
> 是Serial收集器的多线程版本，除了Serial收集器之外，只有它能与CMS收集器配和使用
线程数可通过参数-XX:ParallelGCThreads来指定，默认和cpu核心数相同，可通过
-XX:+UseParNewGC参数强制指定；
##### 3. Parallel Scavenge收集器
> 多线程收集器，用于新生代，采用复制算法，主要控制运行代码时间和GC时间的
比例(吞吐量)
##### 4. Serial Old收集器
> 是Serial收集器的老年代版本，单线程，采用标记-整理算法，适合Client模式下的虚拟机，如果在Server模式下可与Parallel Scavenge收集器搭配使用，或作为CMS收集器的后背预案
##### 5. Parallel Old收集器
> 是Parallel Scavenge收集器的老年代版本，多线程，采用标记-整理算法
##### 6. CMS(Concurrent Mark Sweep)收集器
> 是一种以获取最短停顿时间为目标的收集器，非常适用于B/S架构的服务器；用于老年代，采用标记-清除算法，整个过程分为初始标记->并发标记->重新标记->并发清除四个步骤，其中初始标记和重新标记仍会Stop the world，并发标记时间长但是和用户线程并发执行；
##### 7. G1(Garbaage-First)收集器
> 
##### 8. 垃圾收集器参数总结
|	参数	|	描述	|
|	-----	|	------	|
|	UseSerialGC	|	虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收	|
|	UseParNewGC	|	打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收	|
|	UseConcMarkSweepGC	|	打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用	|
|	UseParallelGC	|	虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收	|
|	UseParallelOldGC	|	打开此开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收	|
|	SurvivorRatio	|	新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden : Survivor=8:1	|
|	PretenureSizeThreshold	|	直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配	|
|	MaxTenuringThreshold	|	晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代	|
|	UseAdaptiveSizePolicy	|	动态调整Java堆中各个区域的大小以及进入老年代的年龄	|
|	HandlePromotionFailure	|	是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况	|
|	ParallelGCThreads	|	设置并行GC时进行内存回收的线程数	|
|	GCTimeRatio	|	GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅使用Parallel Scavenge收集器时生效	|
|	MaxGCPauseMillis	|	设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器生效	|
|	CMSInitiatingOccupancyFraction	|	设置CMS收集器在老年代空间被使用多少后触发垃圾收集，默认值为68%，仅使用CMS收集器时生效	|
|	UseCMSCompactAtFullCollection	|	设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效	|
|	CMSFullGCsBeforeCompaction	|	设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效	|
##### 9. 垃圾收集器和新生代、老年代名称对应


### 内存分配与回收策略
##### 1. 对象优先在eden分配
##### 2. 大对象直接进入老年代
##### 3. 长期存活对象将进入老年代
##### 4. 动态对象年龄判定
##### 5. 空间分配担保
##虚拟机性能监控与故障处理



