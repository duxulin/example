# 第二部分 走近Java
## 第二章 jvm内存管理
### 运行时内存划分
* 程序计数器
> 当前线程执行的字节码的行号指示器，通过改变计数器来选取下一条需执行的字节码指令；
是线程私有的；
* java虚拟机栈
> 线程私有；生命周期与线程相同，是java方法执行的内存模型，每个方法对应一个栈帧；
存储局部变量表、操作数栈、动态链接、方法出口等信息；
* 本地方法栈
> native方法执行的内存模型；
* java堆
> 是虚拟机管理的最大的内存，是线程共享的；主要存放对象、数组，是垃圾收集器
管理的主要区域；可细分为新生代、老年代；亦可再细分为Eden空间 From Survivor空间、
To Survivor空间等；
* 方法区
> 线程共享的；存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等；
(永久带在1.7之后已经移除)
* 运行时常量池
 > 是方法区的一部分
* 直接内存
> 不是虚拟机运行时数据，在NIO中有用到；受本机总内存限制；
### hotspot虚拟机对象探秘
* 对象的创建(普通对象，非数组和Class对象)
> 首先去常量池中定位类的符号引用，并检查类是否已被加载、解析、初始化过，新建对象
所需的内存大小在加载后可以确定；随后会在堆中划分所需大小的内存(不同虚拟机有不
同的实现)；接着把分配的内存初始化为零值，最后执行init;
* 对象的内存布局
> 可分为对象头、实例数据、对齐填充；对象头包含存储对象自身的运行时数据(哈希码、
GC分代年龄、锁状态标志、线程池有的锁、偏向线程ID、偏向时间戳等)和类型指针；
实例数据包括代码中定义的各种类型的字段,包含父类中的字段；对齐填充是为了保障对象
起始地址必须是8字节的整数倍而做的填充；
* 对象的访问定位
> 通过栈上的reference来操作堆上具体对象，有两种定位方式：句柄、直接指针；
句柄形式是在堆内存中划分一块句柄池，reference存句柄的地址，句柄中包含对象实例数据
和类型数据各自的具体地址；直接指针是reference存对象的具体地址，对象头中的类型指针
指向类型数据的地址；后者快，也是HotSpot采用的方式；
### 实战OutOfMemoryError异常
> 除了程序计数器之外，其他的内存区域都有发生OOM异常的可能；
###### 常用jvm参数
````
-Xms20M                             初始堆大小	
-Xmx20M	                            最大堆大小
-Xss128K                              线程栈帧的大小
-XX:+HeapDumpOnOutOfMemoryError     dump堆栈信息
-XX:PermSize=10M                    初始永久带大小(1.7后失效)
-XX:MaxPermSize=10M                 最大永久带大小(1.7后失效)

-XX:+PrintGCDetails                 打印GC详细信息
````


## 第三章 垃圾收集器与内存分配策略
* 为什么要了解GC和内存分配
> 当需要排查各种OOM、GC成为系统达到更高并发量的瓶颈时，需要对这些技术做必要的监控
和调节
### 对象已死吗
##### 1. 引用计数算法
> 描述：每当一个地方引用它，计数器+1，引用失效时，计数器-1，任何时刻计数器==0时，
对象不能再使用了；缺点：对象之间互相循环引用
##### 2. 可达性算法
> 描述：从一系列GC Roots的对象作为起点，通过引用链(Reference Chain)判定对象
是否可达；
###### GCRoots对象
    1. 虚拟机栈(本地变量表)中引用的对象
    2. 方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象
    4. 本地方法栈中native引用的对象
##### 3. 引用
> 引用可分为强引用(Strong Reference)、软引用(Soft Reference)、
弱引用(Weak Reference)、虚引用(Phantom Reference)强引用为new的对象，
 其他引用在jdk中都有对应的类
##### 4. 生存还是死亡
> finalize()是GC在收集垃圾之前会执行的，只有被覆盖了才会执行(不建议自己覆盖)
#### 5. 回收方法区
### 垃圾收集算法
#####1. 标记-清除算法
> 描述：在判定对象是否已经死亡(是否可达)时候，将死亡的对象作标记，是最基础的算法;
缺点：①标记和清除两个过程效率不高；②会产生大量不连续的内存碎片，导致无法分配足够
的连续内存而提前触发另一次GC
#####2. 复制算法
> 描述： 将内存划分为相同大小的两块，每次使用一块，当这块内存用完了，就将存活
的对象复制到另一块，再把这块内存清空；缺点：内存缩小到原来的一半；(新生代采用)
#####3. 标记-整理算法：
> 描述：将对象标记后，将存活的对象向一端移动，然后直接清除端边界以外的内存
(老年代采用)
#####4.分代收集算法
> 描述：根据对象存活周几不同将内存划分为几块，一般分为新生代、老年代，再根据不同周期
的特点采用最适当的手机算法；(新生代采用复制算法)(老年代采用标记-清理或标记-整理)
### HotSpot的算法实现
##### 1. 枚举根节点
##### 2. 安全点
##### 3. 安全区域
### 垃圾收集器
![垃圾收集器组合图](https://cdn.app.compendium.com/uploads/user/e7c690e8-6ff9-102a-ac6d-e4aebca50425/f4a5b21d-66fa-4885-92bf-c4e81c06d916/Image/b125abbe194f5608840119eccc9d90e2/collectors.jpg)
##### 1. Serial收集器
> 单线程收集器，用于新生代垃圾收集，采用复制算法；适合在桌面应用场景中使用
(运行在Client模式下的虚拟机)
##### 2. ParNew收集器
> 是Serial收集器的多线程版本，除了Serial收集器之外，只有它能与CMS收集器配和使用
线程数可通过参数-XX:ParallelGCThreads来指定，默认和cpu核心数相同，可通过
-XX:+UseParNewGC参数强制指定；
##### 3. Parallel Scavenge收集器
> 多线程收集器，用于新生代，采用复制算法，主要控制运行代码时间和GC时间的
比例(吞吐量)
##### 4. Serial Old收集器
> 是Serial收集器的老年代版本，单线程，采用标记-整理算法，适合Client模式下的虚拟机，如果在Server模式下可与Parallel Scavenge收集器搭配使用，或作为CMS收集器的后背预案
##### 5. Parallel Old收集器
> 是Parallel Scavenge收集器的老年代版本，多线程，采用标记-整理算法
##### 6. CMS(Concurrent Mark Sweep)收集器
> 是一种以获取最短停顿时间为目标的收集器，非常适用于B/S架构的服务器；用于老年代，采用标记-清除算法，整个过程分为初始标记->并发标记->重新标记->并发清除四个步骤，其中初始标记和重新标记仍会Stop the world，并发标记时间长但是和用户线程并发执行；
##### 7. G1(Garbaage-First)收集器
> 
##### 8. 垃圾收集器参数总结
|	参数	|	描述	|
|	-----	|	------	|
|	UseSerialGC	|	虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收	|
|	UseParNewGC	|	打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收	|
|	UseConcMarkSweepGC	|	打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用	|
|	UseParallelGC	|	虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收	|
|	UseParallelOldGC	|	打开此开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收	|
|	SurvivorRatio	|	新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden : Survivor=8:1	|
|	PretenureSizeThreshold	|	直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配	|
|	MaxTenuringThreshold	|	晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代	|
|	UseAdaptiveSizePolicy	|	动态调整Java堆中各个区域的大小以及进入老年代的年龄	|
|	HandlePromotionFailure	|	是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况	|
|	ParallelGCThreads	|	设置并行GC时进行内存回收的线程数	|
|	GCTimeRatio	|	GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅使用Parallel Scavenge收集器时生效	|
|	MaxGCPauseMillis	|	设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器生效	|
|	CMSInitiatingOccupancyFraction	|	设置CMS收集器在老年代空间被使用多少后触发垃圾收集，默认值为68%，仅使用CMS收集器时生效	|
|	UseCMSCompactAtFullCollection	|	设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效	|
|	CMSFullGCsBeforeCompaction	|	设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效	|
##### 9. 垃圾收集器和新生代、老年代名称对应


### 内存分配与回收策略
##### 1. 对象优先在eden分配
##### 2. 大对象直接进入老年代
##### 3. 长期存活对象将进入老年代
##### 4. 动态对象年龄判定
##### 5. 空间分配担保
## 第四章 虚拟机性能监控与故障处理
### jdk命令行工具
##### 1. jsp:虚拟机进程状况工具；
##### 2. jstat:需积极统计信息监视工具
##### 3. jinfo:java配置信息工具
##### 4. jmap:java内存映像工具
##### 5. jhat:新建堆转存储快照分析工具
##### 6. jstack: java堆栈跟踪工具
##### 7. hsdis:jit生成代码反汇编
### jdk可视化工具
##### 1. jconsole:java监视与管理控制台
##### 2. visualVM:多合一故障处理工具


## 第五章 调优案例分析与实战
# 第三部分 虚拟机执行子系统
## 第六章 类文件结构
### class类文件结构
### 字节码指令
##### 1. 加载和存储指令
##### 2. 运算指令
##### 3. 类型转换指令
##### 4. 对象创建与访问指令
##### 5. 操作数栈管理指令
##### 6. 控制转移指令
##### 7. 方法调用和返回指令
##### 8. 异常处理指令
##### 9. 同步指令
## 第七章 虚拟机类加载机制
### 类加载时机
##### 1. 类生命周期
加载->验证->准备->解析->初始化->使用->卸载，其中验证、准备、解析三个阶段统称为连接
##### 2.类加载时机
> 虚拟机规范未强制约束加载时机，但要求了类的初始化时机
````
会初始化的时机
    * 使用new关键字、读取或设置静态字段(final修饰，已在编译器把结果放入常量池中的除外)、调用类的静态方法；
    * 使用reflect包的方法对类惊醒反射调用；
    * 当初始化一个类，其父类还没被初始化；
    * 当虚拟机启动时，用户需要指定执行的主类(main)
    
不会初始化的时机
    * 子类调用父类的静态字段，子类不会初始化；
    * 创建类的数组，不会初始化类(数组对应的class是由虚拟机生成的)
    * 调用类的静态 final字段，且字段不由new生成（基本数据类型、string="abc"不会触发，string= new String("abc");会触发
````
### 类加载过程
##### 加载
>1.加载，虚拟机
##### 验证
> 确保class文件的字节流中包含的信息符合当前虚拟机的要求，包括文件格式验证、元数据验证、字节码验证、符号引用验证
##### 准备
> 为类(static)变量分配内存地址并设置初始值,为类常量(final修饰的字段)分配内存并设置初始值；
##### 解析
> 将常量池内的符号引用替换为直接引用
##### 初始化
> 编译器会将类的静态字段、代码块收集成<cinit>()的类构造方法进行初始化，程序运行的第一个<cinit>()是Object，为静态字段设置值；
### 类加载器
> 类加载器和类全限定名确定虚拟机中类的唯一性；
##### 双亲委派模型
> jdk提供三个类加载器，Bootstrap ClassLoader(启动类加载器，由jvm调用,加载%JAVA_HOME%/lib下的jar包)，Extension ClassLoader(扩展类加载器，加载java.ext.dir系统变量所指定的路径中的所有jar),和Application ClassLoader(加载classpath路径下的jar)
> 
## 第八章 虚拟机字节码执行引擎
### 运行时栈帧结构
> 栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息，在编译期间已经确定了局部变量表的大小，操作数栈的深度
##### 局部变量表
> 编译器确定数量及solt位置
##### 操作数栈
> Last In First Out结构，在编译器确定栈的深度
##### 动态连接
##### 方法返回地址
###方法调用





