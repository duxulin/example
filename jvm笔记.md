## jvm内存管理
### 运行时内存划分
* 程序计数器
> 当前线程执行的字节码的行号指示器，通过改变计数器来选取下一条需执行的字节码指令；
是线程私有的；
* java虚拟机栈
> 线程私有；生命周期与线程相同，是java方法执行的内存模型，每个方法对应一个栈帧；
存储局部变量表、操作数栈、动态链接、方法出口等信息；
* 本地方法栈
> native方法执行的内存模型；
* java堆
> 是虚拟机管理的最大的内存，是线程共享的；主要存放对象、数组，是垃圾收集器
管理的主要区域；可细分为新生代、老年代；亦可再细分为Eden空间 From Survivor空间、
To Survivor空间等；
* 方法区
> 线程共享的；存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等；
* 运行时常量池
 > 是方法区的一部分
* 直接内存
> 不是虚拟机运行时数据，在NIO中有用到；受本机总内存限制；
### hotspot虚拟机对象探秘
* 对象的创建(普通对象，非数组和Class对象)
> 首先去常量池中定位类的符号引用，并检查类是否已被加载、解析、初始化过，新建对象所需
的内存大小在加载后可以确定；随后会在堆中划分所需大小的内存(不同虚拟机有不同的实现)；
接着把分配的内存初始化为零值，最后执行init;
* 对象的内存布局
> 可分为对象头、实例数据、对齐填充；对象头包含存储对象自身的运行时数据(哈希码、
GC分代年龄、锁状态标志、线程池有的锁、偏向线程ID、偏向时间戳等)和类型指针；
实例数据包括代码中定义的各种类型的字段包含父类中的字段；对齐填充是为了保障对象起始地址
必须是8字节的整数倍而做的填充；
* 对象的访问定位
> 通过栈上的reference来操作堆上具体对象，有两种定位方式：句柄、直接指针；
句柄形式是在堆内存中划分一块句柄池，reference存句柄的地址，句柄中包含对象实例数据
和类型数据各自的具体地址；直接指针是reference存对象的具体地址，对象头中的类型指针
指向类型数据的地址；后者快，也是HotSpot采用的方式；
### 实战OutOfMemoryError异常
> 除了程序计数器之外，其他的内存区域都有发生OOM异常的可能；




